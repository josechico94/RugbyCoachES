<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>RugbyBoard Pro — Animación + Export (Firestore)</title>
<script type="module">
// --- Configuración e Inicialización de Firebase (OBLIGATORIO) ---
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, signInWithCustomToken, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, setDoc, deleteDoc, collection, query, onSnapshot, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

// Habilitar logs de depuración (CORRECCIÓN: 'debug' es el valor correcto)
setLogLevel('debug');

// CONFIGURACIÓN PROPORCIONADA POR EL USUARIO:
const firebaseConfig = {
    apiKey: "AIzaSyDCIY11FyQxKZY3hwBGNWixtaK_SFZko6k",
    authDomain: "rugbycoach-f0b23.firebaseapp.com",
    projectId: "rugbycoach-f0b23",
    storageBucket: "rugbycoach-f0b23.firebasestorage.app",
    messagingSenderId: "536069158649",
    appId: "1:536069158649:web:ead82ceea04f5d7ab39428",
    measurementId: "G-XF5Q0WB0V0"
};

// Obtenemos el App ID directamente de la configuración
const appId = firebaseConfig.appId || 'default-app-id';

// Usamos el token de autenticación si está disponible en el entorno
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

let app, db = null, auth, userId = 'local_storage'; // db initialised to null
let isAuthorized = false; // Estado de autorización
let appInitialized = false; // Bandera para asegurar que initBoardApp solo se llame una vez

// IMPORTANTE: LISTA DE USUARIOS AUTORIZADOS
// SOLO TU UID DE ENTRENADOR ESTÁ AQUÍ.
const AUTHORIZED_USERS_IDS = [
    'YZyCoUgkMsOtP7gmWe1qdlWmaug1', // TU UID DE ENTRENADOR
    // ... el UID correcto se pegará aquí
];

// Ruta de la colección para guardar las jugadas. 
// Usamos una colección PUBLIC/GLOBAL para que todos puedan leer.
const getPlayCollectionRef = () => collection(db, `artifacts/${appId}/public/data/rugby_plays`);

/**
 * Gestiona el cambio de estado de autenticación (login/logout).
 * Actualiza los permisos y la UI sin recargar la página.
 */
function handleAuthStateChange(user) {
    if (user) {
        // Usuario autenticado
        userId = user.uid;
        window.userId = userId;

        // Determinar si es un Entrenador (Authorized)
        const newIsAuthorized = AUTHORIZED_USERS_IDS.includes(userId);
        window.isAuthorized = newIsAuthorized;
        isAuthorized = newIsAuthorized; // Sincroniza la variable local

        console.log(`Auth State Changed: UID=${userId}. Autorizado: ${isAuthorized} (Anónimo: ${user.isAnonymous})`);

        // 1. Ocultar el modal de login si está visible
        loginModal.style.display = 'none';
        
        // 3. Actualizar el estado de los controles
        setControlsDisabled(!isAuthorized);
        
        // 4. Actualizar el botón de autenticación
        updateAuthButton(true); // Siempre que haya user, está logueado
        
        // 5. Refrescar la lista de jugadas (se conecta a Firestore si userId es válido)
        refreshPlayList();

        // 6. Actualizar el indicador de la marca
        document.getElementById('brand').innerHTML = `<span class="dot"></span>RugbyBoard Pro (Cloud) ${isAuthorized ? '(Entrenador)' : '(Espectador)'}`;

        // Habilitar interacciones si es Entrenador
        if (isAuthorized) {
            reInitializePlayerInteractions();
            // CORRECCIÓN 1: Mensaje amigable, NO mostrar el UID
            showStatus(`¡Bienvenido! Has iniciado sesión correctamente.`, 'var(--accent2)');
        } else {
             // Muestra el UID para que el usuario pueda copiarlo si es una cuenta no autorizada
             showStatus(`Sesión Iniciada como Espectador.`, 'var(--warn)');
        }
        
    } else {
        // No hay usuario activo: MODO LECTOR (Desconectado/Espectador)
        userId = 'unauthenticated';
        window.userId = userId;
        window.isAuthorized = false;
        isAuthorized = false;
        
        // Si no hay usuario activo, aseguramos que los controles estén deshabilitados
        setControlsDisabled(true); 
        updateAuthButton(false);
        document.getElementById('brand').innerHTML = `<span class="dot"></span>RugbyBoard Pro (Cloud) (Modo Lector)`;
        
        // El modo Lector/Espectador solo requiere que la app cargue la lista de jugadas
        refreshPlayList(); 
    }
}


// **************** DEFINICIÓN DE initBoardApp ****************
window.initBoardApp = function initBoardApp(){
  // players & ball
  createPlayers();
  placeBall();
  
  // Si no hay timeline, crea un frame inicial
  if (!timeline.length) { recordFrame(); }
  updateScrub();

  // Inicia la suscripción a Firestore para la lista de jugadas
  refreshPlayList(); // Llama a la función unificada que maneja el fallback
  
  // Aplica las restricciones de permisos
  setControlsDisabled(!window.isAuthorized);

  // FIX CRÍTICO: Solo intenta actualizar el estado de autenticación si Firebase Auth está inicializado.
  if (window.auth) {
      // Verificamos si hay un usuario logueado (no nulo) y si no es anónimo
      updateAuthButton(window.auth.currentUser); // Pasa el objeto user para determinar el estado
      
      // FIX: Asegurar que el botón de autenticación esté visible si el Auth está vivo
      btnAuthAction.style.display = 'inline-block'; 
  } else {
      // Si Firebase falló (modo local), ocultamos el botón de Auth (no hay cloud para iniciar sesión)
      btnAuthAction.style.display = 'none';
  }
  
  // eventos de drag para el balón
  enableDragBall(()=>{ if (autoRec.checked) recordFrame(); });
  
  // Nuevo: Habilitar la selección masiva con recuadro
  enableSelectionBox();

  // eventos UI
  document.getElementById('showGrid').checked=false; renderGrid();
  // El snap grilla ha sido eliminado.
  
  // Render inicial y layout
  renderDraw();
  fitBoard(); 
  // FIX: Se añade un pequeño timeout para forzar el cálculo correcto del layout
  // cuando el DOM no está completamente renderizado en navegadores locales.
  setTimeout(fitBoard, 50); 
}
/* ----------------------------------------------------------- */


// Función de inicialización asíncrona
async function initFirebaseAndApp() {
    try {
        // 1. Inicialización de Firebase
        app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);
        
        // Exponemos servicios
        window.db = db;
        window.auth = auth; 
        window.getPlayCollectionRef = getPlayCollectionRef;
        window.onSnapshot = onSnapshot;
        window.doc = doc;
        window.setDoc = setDoc;
        window.deleteDoc = deleteDoc;
        window.query = query;
        window.signInWithEmailAndPassword = signInWithEmailAndPassword;
        window.signOut = signOut;
        
        // 2. LÓGICA NO-BLOQUEANTE: Inicializar el Canvas inmediatamente
        if (!appInitialized) {
            appInitialized = true;
            window.initBoardApp(); // LLAMADA NO-BLOQUEANTE (Ahora definida)
        }
        
        // 3. Listener de cambio de estado de autenticación (ASÍNCRONO)
        onAuthStateChanged(auth, (user) => {
            if (user) { 
                // Usuario autenticado (email/pass)
                handleAuthStateChange(user);
            } else {
                // Si NO hay usuario, simplemente pasamos el estado nulo.
                handleAuthStateChange(null);
            }
        });
        
        // 4. Intentar iniciar sesión con Custom Token (si está disponible y no hay sesión aún)
        if (initialAuthToken) {
            try {
                // Intentamos sin esperar, el onAuthStateChanged manejará el resultado
                signInWithCustomToken(auth, initialAuthToken).catch(e => console.warn("Custom token falló:", e.code));
            } catch (authError) {
                console.warn("Error en el intento de signInWithCustomToken:", authError.code);
            }
        }
        
    } catch (error) {
        // Fallo total de Firebase: se activa el fallback a Local Storage (que es modo edición)
        console.error("Firebase initialization failed, switching to local storage:", error);
        db = null; 
        window.db = null;
        window.isAuthorized = true; 
        
        // Activa el modo local (Edición Completa) y la inicialización.
        document.getElementById('brand').innerHTML = `<span style="color:var(--warn);width:12px;height:12px;border-radius:50%;background:var(--warn);display:inline-block;margin-right:10px;"></span>RugbyBoard Pro (Local - Edición)`;
        
        // FIX: Llama a initBoardApp si falló Firebase, pero solo si aún no se inicializó.
        if (!appInitialized) {
            appInitialized = true;
            window.initBoardApp();
        }
    }
}

// Establecer la función de inicialización en el ámbito global
window.initFirebaseAndApp = initFirebaseAndApp;

// LLAMADA CORREGIDA: Llamamos a la función inmediatamente después de que el módulo esté definido.
window.initFirebaseAndApp();

</script>
<style>
  :root{
    --bg:#0b1520; --panel:#0e1c2a; --panel2:#122235; --ink:#e8eef5; --muted:#9fb3c8;
    --border:#1b3147; --accent:#00c2ff; --accent2:#7ef29a; --warn:#ffd400; --red:#ff5a6b; --blue:#2f80ff;
    --shadow:0 8px 28px rgba(0,0,0,.35);
    --r:12px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .app{display:grid;grid-template-rows:auto 1fr auto;min-height:100dvh}

  /* Top bar */
  .topbar{display:flex;align-items:center;gap:12px;padding:10px 14px;background:linear-gradient(180deg,#0f2235,#0c1a29);border-bottom:1px solid var(--border);position:sticky;top:0;z-index:100}
  .brand{display:flex;align-items:center;gap:10px;font-weight:700}
  .brand .dot{width:12px;height:12px;border-radius:50%;background:var(--accent)}
  .toolbar{display:flex;gap:8px;margin-left:auto;flex-wrap:wrap}
  .btn{appearance:none;border:1px solid var(--border);background:#122538;color:var(--ink);padding:.55rem .8rem;border-radius:10px;cursor:pointer}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .btn.primary{background:#0f2a3f;border-color:#22445f}
  .seg{display:flex;border:1px solid var(--border);border-radius:10px;overflow:hidden}
  .seg button{border:none;background:#13293d;padding:.45rem .7rem;color:var(--ink);cursor:pointer}
  .seg button.active{background:#15354f;color:#7fe7ff}

  /* Stage - Contenedor del tablero */
  .stage{position:relative;display:grid;grid-template-columns: 1fr;grid-template-rows:1fr;min-height:calc(100dvh - 180px); padding: 12px;}
  /* CORRECCIÓN DE CENTRADO: Usamos flexbox para asegurar que el contenido se centre verticalmente y horizontalmente */
  .board-viewport{
    position:relative;
    inset:0;
    display:flex; /* Cambiado de grid a flex */
    justify-content: center; /* Centrado horizontal */
    align-items: center; /* Centrado vertical */
    overflow:hidden; 
    border-radius: 12px;
  }
  /* Aseguramos que el wrap no se mueva de su posición inicial, solo se transforme */
  .board-wrap{position:relative; width:1200px; height:700px; transform-origin:top left;} 
  .board{position:absolute;inset:0;background:#137a46;border-radius:16px;box-shadow:var(--shadow);overflow:hidden}
  .lines, .draw{position:absolute;inset:0;pointer-events:none}
  svg{width:100%;height:100%;display:block}
  .grid{position:absolute;inset:0;pointer-events:none;opacity:.55;display:none}
  .grid.on{display:block}

  /* Players & ball */
  #players{position:absolute;inset:0;z-index:3;pointer-events:none}
  .player{pointer-events:auto;position:absolute;width:40px;height:40px;border-radius:50%;display:grid;place-items:center;font-weight:800;font-size:14px;color:#fff;border:2px solid #fff;box-shadow:0 4px 16px rgba(0,0,0,.3);cursor:grab}
  .player.selected{border: 3px solid var(--accent); box-shadow: 0 0 10px var(--accent);} /* Estilo para selección masiva */
  .blue{background:var(--blue)} .red{background:var(--red)}
  /* NUEVOS COLORES PARA EQUIPOS */
  .team-1{background:var(--blue);}
  .team-2{background:var(--red);}
  
  #ball{position:absolute;z-index:4}
  .ball{width:50px;height:30px;background:var(--warn);border:2px solid #fff;border-radius:50%/60%;transform:translate(-50%,-50%) rotate(-15deg);box-shadow:0 3px 12px rgba(0,0,0,.35);cursor:grab}
  .ball::after{content:"";position:absolute;inset:6px 18px;border-radius:50%/60%;border:2px dashed rgba(0,0,0,.25)}
  
  /* Selection Box */
  #selectionBox{
      position: absolute;
      pointer-events: none;
      border: 1px dashed var(--accent);
      background: rgba(0, 194, 255, 0.1);
      z-index: 5;
      display: none;
  }

  /* Bottom dock (tools) */
  .dock{position:sticky;bottom:0;background:linear-gradient(0deg,#0d1f30,#0b1928);border-top:1px solid var(--border);z-index:90}
  /* En móvil, el dock ocupa todo el ancho */
  .dock-inner{display:grid;grid-template-columns:1fr;gap:10px;padding:10px 14px;} /* Ajuste de padding */
  .row{display:flex;flex-wrap:wrap;gap:8px}
  .field{display:flex;align-items:center;gap:8px;background:#0f2032;border:1px solid var(--border);border-radius:10px;padding:.5rem .6rem}
  .field label{font-size:.85rem;color:var(--muted)}
  select,input[type="number"],input[type="text"]{background:#0c1c2b;color:var(--ink);border:1px solid var(--border);border-radius:8px;padding:.45rem .55rem}
  input[type="checkbox"]{width:18px;height:18px}
  .grow{flex:1}
  .subtle{color:var(--muted);font-size:.85rem}
  
  /* Gemini Assistant Styles */
  #geminiAssistantOutput {
    background: var(--panel2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px;
    margin-top: 10px;
    white-space: pre-wrap; /* Mantiene saltos de línea del LLM */
    font-size: 0.9rem;
  }
  
  .loader {
    border: 3px solid var(--border);
    border-top: 3px solid var(--accent);
    border-radius: 50%;
    width: 20px;
    height: 20px;
    animation: spin 1s linear infinite;
    display: inline-block;
    vertical-align: middle;
    margin-left: 10px;
  }
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  /* Modal Login */
  .modal-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background-color: rgba(0, 0, 0, 0.7);
    display: none;
    place-items: center;
    z-index: 1000;
  }
  .modal-content {
    background-color: var(--panel);
    padding: 24px;
    border-radius: 12px;
    box-shadow: var(--shadow);
    width: 90%;
    max-width: 400px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    border: 1px solid var(--border);
  }
  .modal-content input {
    width: 100%;
    padding: 10px;
  }
  .modal-content button {
    margin-top: 10px;
  }


  /* ---------------------- ESTILOS DE DESKTOP (Side Panel) ---------------------- */
  @media (min-width: 1000px){
    .app{grid-template-rows:auto 1fr} /* Eliminar el footer que se muestra abajo */
    .stage{
        grid-template-columns: 320px 1fr; /* Panel a la izquierda */
        gap:14px; 
        padding:12px; 
        display: grid; 
        min-height: calc(100dvh - 70px); 
    }
    
    /* Panel lateral: visible en desktop */
    .sidepanel{
        position: relative; /* Restaura el flujo normal de la grid */
        background:var(--panel);
        border:1px solid var(--border);
        border-radius:12px;
        padding:12px;
        display:flex; 
        flex-direction:column;
        gap:12px; 
        min-height: 100%; 
        overflow-y: auto; 
        /* Reset de propiedades móviles */
        transform: translateX(0) !important;
    }
    
    .dock, #btnMenuOpen { display: none !important; }
    
    /* Reglas de separación visual */
    .sidepanel-section { padding-top: 0 !important; border-top: none !important; }
    .sidepanel-section + .sidepanel-section { border-top: 1px solid var(--border) !important; padding-top: 12px !important; }
  }


  /* ---------------------- ESTILOS DE MOBILE (Hamburguesa y Campo Completo) ---------------------- */
  @media (max-width: 999px) {
    
    .app { 
        min-height: 100dvh; 
        grid-template-rows: auto 1fr; /* Topbar y Campo (El dock inferior está eliminado) */
    }
    
    /* Campo de Juego: Prioridad absoluta */
    .stage {
        padding: 0; 
        min-height: auto;
        /* Aseguramos que el campo ocupe el 100% del espacio restante */
        height: 100%; 
    }
    .board-viewport {
        width: 100%;
        height: 100%;
    }
    
    /* Ocultar el selector de orientación de la topbar en móvil */
    .topbar .seg { display: none !important; }
    
    /* Botón de Hamburguesa (Abrir menú) */
    #btnMenuOpen {
        display: inline-flex;
    }

    /* Ocultar el sidepanel DE ESCRITORIO y transformarlo en el menú de hamburguesa */
    .sidepanel {
        position: fixed;
        top: 0;
        left: 0;
        bottom: 0;
        width: 300px;
        max-width: 85vw;
        z-index: 1000;
        background: var(--bg);
        transform: translateX(-100%);
        transition: transform 0.3s ease-out;
        box-shadow: 4px 0 10px rgba(0,0,0,0.5);
        padding-top: 60px; /* Para dejar espacio al header del menú */
        display: flex; /* Mostrar como flex para el contenido */
    }
    
    /* Clase para mostrar el menú */
    .sidepanel.open {
        transform: translateX(0);
    }
    
    /* El dock inferior ha sido eliminado */
    .dock { display: none !important; }
    
    /* Overlay para cerrar el menú con un tap */
    #menuOverlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
        display: none;
    }
    #menuOverlay.open {
        display: block;
    }
    
  }

  /* Estilos del header del menú de hamburguesa (para móvil) */
  #menuHeader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 60px;
      z-index: 1001;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      display: none;
      align-items: center;
      justify-content: space-between;
      padding: 0 14px;
  }
  .sidepanel.open ~ #menuHeader {
      display: flex;
  }

  /* Ícono de hamburguesa */
  .icon-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 8px;
    color: var(--ink);
    display: flex;
    align-items: center;
  }
  .icon-btn svg {
    width: 24px;
    height: 24px;
  }
  #btnMenuOpen {
      display: none;
  }
  @media (max-width: 999px) {
      #btnMenuOpen {
          display: inline-block;
      }
  }


</style>
<!-- FFmpeg.wasm UMD -->
<script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/umd/ffmpeg.min.js"></script>
</head>
<body>
  <!-- Overlay para cerrar menú móvil con tap -->
  <div id="menuOverlay" style="display:none;"></div>

  <!-- Modal de Login -->
  <div class="modal-overlay" id="loginModal">
    <div class="modal-content">
        <h3 style="font-weight:700; color:var(--accent);">Acceso Requerido</h3>
        <p class="subtle">Por favor, inicia sesión con tu cuenta de club para acceder al tablero.</p>
        
        <input type="email" id="loginEmail" placeholder="Email"/>
        <input type="password" id="loginPassword" placeholder="Contraseña"/>
        
        <button class="btn primary" id="btnLogin">Iniciar Sesión</button>
        <p id="loginMessage" style="color:var(--red); font-size:0.85rem; margin:0;"></p>
        <button class="btn" id="btnCloseLogin" style="display:none;">Cerrar</button>
    </div>
  </div>
  
  <!-- Contenedor del header móvil (solo para el menú desplegado) -->
  <div id="menuHeader">
      <span class="brand" style="font-size: 1.1rem;"><span class="dot"></span>Controles</span>
      <button class="icon-btn" id="btnCloseMenu">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
              <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
          </svg>
      </button>
  </div>


  <!-- Contenedor de la aplicación -->
  <div class="app">
    <!-- Topbar -->
    <header class="topbar">
      <div class="brand" id="brand"><span class="dot"></span>RugbyBoard Pro (Cargando...)</div>

      <!-- Controles de Orientación (SOLO DESKTOP) -->
      <div class="seg" id="orientationSeg">
        <button id="btnLandscape" class="active" title="Horizontal">Horizontal</button>
        <button id="btnPortrait" title="Vertical">Vertical</button>
      </div>

      <div class="toolbar">
        <button class="btn" id="btnReset" disabled>Reiniciar</button>
        <button class="btn primary" id="btnSavePlay" disabled>Guardar jugada</button>
        <button class="btn" id="btnLoadPlay" disabled>Cargar</button>
        <button class="btn" id="btnExportJpg">JPG</button>
        <button class="btn" id="btnExportWebm">WebM</button>
        <button class="btn" id="btnExportMp4">MP4</button>
        <!-- BOTÓN DE LOGIN/LOGOUT -->
        <button class="btn primary" id="btnAuthAction">Modo Entrenador</button>
        <!-- BOTÓN DE HAMBURGUESA (SOLO MÓVIL) -->
         <button class="icon-btn" id="btnMenuOpen">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
              </svg>
         </button>
      </div>
    </header>

    <!-- Main stage -->
    <main class="stage">
      
      <!-- Panel lateral (Desktop) / Menú Desplegable (Móvil) -->
      <aside class="sidepanel" id="desktopSidepanel">
          
        <!-- ---------------------- CONTROLES DE ESCRITORIO / HAMBURGUESA MÓVIL ---------------------- -->
        
        <!-- CONTROLES DE ORIENTACIÓN EN MÓVIL (Mover el control de orientación del topbar aquí) -->
        <div id="mobileOrientationControls" class="sidepanel-section mobile-only" style="display:none; flex-direction:column; gap:10px;">
             <h3 style="font-weight:700; font-size:1.1rem; color:var(--accent);">Orientación</h3>
             <div class="seg" style="margin-top: 5px;">
                  <button id="btnLandscapeMobile">Horizontal</button>
                  <button id="btnPortraitMobile">Vertical</button>
             </div>
        </div>

        <!-- 4. Asistente Táctico Gemini ✨ -->
        <!-- CORRECCIÓN 2: MÓDULO ASISTENTE TÁCTICO OCULTO -->
        <!-- 
        <div id="geminiAssistantSection" class="sidepanel-section" style="display:flex; flex-direction:column; gap:10px;">
          <h3 style="font-weight:700; font-size:1.1rem; color:var(--accent);">Asistente Táctico ✨</h3>
          <p class="subtle" style="margin:0; font-size:.8rem;">Obtén un análisis instantáneo de la formación actual en el campo.</p>
          
          <button class="btn primary" id="btnGeminiAnalyze">Analizar Formación</button>

          <div id="geminiAssistantOutput">
            Haz clic en 'Analizar Formación' para obtener un reporte de Gemini.
          </div>
        </div> 
        -->
        
        <!-- 3. Controles de dibujo -->
        <div id="drawingControlsSection" class="sidepanel-section" style="display:flex; flex-direction:column; gap:10px;">
          <h3 style="font-weight:700; font-size:1.1rem; color:var(--accent);">Herramientas de Dibujo</h3>
          <div class="row">
            <div class="seg" id="toolSeg">
              <button id="toolArrows" class="active" disabled>Flechas</button>
              <button id="toolPen" disabled>Lápiz</button>
              <button id="toolText" disabled>Texto</button> <!-- NUEVO BOTÓN DE TEXTO -->
            </div>
            <button class="btn" id="btnUndo" disabled>Deshacer</button>
            <button class="btn" id="btnClear" disabled>Borrar dibujos</button>
          </div>
          <div class="row">
            <div class="field">
              <label>Color</label>
              <select id="strokeColor" disabled>
                <option value="#ffffff">Blanco</option>
                <option value="#35d07f">Verde</option>
                <option value="#2f80ff">Azul</option>
                <option value="#ff5a6b">Rojo</option>
                <option value="#ffd400" selected>Amarillo</option>
              </select>
            </div>
            <div class="field">
              <label>Grosor</label>
              <select id="strokeWidth" disabled>
                <option value="3">Fino</option>
                <option value="5" selected>Medio</option>
                <option value="7">Grueso</option>
              </select>
            </div>
            <div class="field">
              <input type="checkbox" id="dashed" disabled> <label for="dashed">Punteado</label>
            </div>
          </div>
          <!-- CORRECCIÓN 3: ELIMINAR SNAP GRILLA -->
          <div class="row">
            <div class="field">
              <!-- input type="checkbox" id="snap" disabled> <label for="snap">Snap grilla</label -->
            </div>
            <div class="field">
              <input type="checkbox" id="showGrid" disabled> <label for="showGrid">Ver grilla</label>
            </div>
          </div>
        </div>
        
        <!-- 1. Sección de Jugadas (Play Management) -->
        <div id="playManagementSection" class="sidepanel-section" style="display:flex; flex-direction:column; gap:10px;">
          <h3 style="font-weight:700; font-size:1.1rem; color:var(--accent);">Gestión de Jugadas</h3>
          <div class="field grow">
            <label class="subtle">Nombre de Jugada (ID en DB)</label>
            <input type="text" id="playName" placeholder="Ej: Lineout 8" class="grow" disabled/>
          </div>
          <div class="row">
            <button class="btn" id="btnDuplicate" disabled>Duplicar (Local)</button>
            <select id="playList" class="btn grow" disabled>
              <option value="">Modo Lector: Cargando jugadas...</option>
            </select>
            <button class="btn" id="btnDelete" disabled>Eliminar</button>
          </div>
        </div>

        <!-- 2. Sección de Timeline y Animación -->
        <div id="timelineSection" class="sidepanel-section" style="display:flex; flex-direction:column; gap:10px;">
          <h3 style="font-weight:700; font-size:1.1rem; color:var(--accent);">Control de Animación</h3>
          <div class="row">
            <button class="btn grow" id="btnRecord" disabled>Grabar paso</button>
            <div class="field">
              <input type="checkbox" id="autoRec" disabled> <label for="autoRec">Auto al soltar</label>
            </div>
          </div>
          <!-- CORRECCIÓN 4: UN SOLO BOTÓN PLAY/PAUSE -->
          <div class="row">
            <button class="btn primary" id="btnPlayPause">Reproducir</button>
            <!-- <button class="btn" id="btnPause">Pause</button> -->
            <button class="btn" id="btnStop">Stop</button>
            <div class="field grow">
              <label>Velocidad (ms)</label>
              <input type="number" id="speed" min="100" step="100" value="800" style="width:100px"/>
            </div>
          </div>
          <div class="field grow">
            <label>Frame</label>
            <input type="range" id="scrubber" min="0" max="0" value="0" class="grow"/>
            <span id="scrubLbl" class="subtle">0/0</span>
          </div>
          <button class="btn" id="btnClrTl" disabled>Limpiar animación</button>
        </div>
      </aside>

      <section class="board-viewport" id="boardViewport">
        <div class="board-wrap" id="boardWrap">
          <div class="board" id="board">
            <!-- field lines -->
            <svg class="lines" viewBox="0 0 1200 700" preserveAspectRatio="none" aria-hidden="true">
              <rect x="5" y="5" width="1190" height="690" fill="none" stroke="#fff" stroke-width="6"/>
              <rect x="0" y="0" width="80" height="700" fill="rgba(255,255,255,.07)"/>
              <rect x="1120" y="0" width="80" height="700" fill="rgba(255,255,255,.07)"/>
              <line x1="80" y1="0" x2="80" y2="700" stroke="#fff" stroke-width="4"/>
              <line x1="1120" y1="0" x2="1120" y2="700" stroke="#fff" stroke-width="4"/>
              <line x1="309" y1="0" x2="309" y2="700" stroke="#fff" stroke-width="3"/>
              <line x1="891" y1="0" x2="891" y2="700" stroke="#fff" stroke-width="3"/>
              <line x1="500" y1="0" x2="500" y2="700" stroke="#fff" stroke-width="2" stroke-dasharray="8 10"/>
              <line x1="697" y1="0" x2="697" y2="700" stroke="#fff" stroke-width="2" stroke-dasharray="8 10"/>
              <line x1="600" y1="0" x2="600" y2="700" stroke="#fff" stroke-width="4"/>
              <line x1="5" y1="50" x2="1195" y2="50" stroke="#fff" stroke-width="2" stroke-dasharray="4 8"/>
              <line x1="5" y1="150" x2="1195" y2="150" stroke="#fff" stroke-width="2" stroke-dasharray="4 8"/>
              <line x1="5" y1="550" x2="1195" y2="550" stroke="#fff" stroke-width="2" stroke-dasharray="4 8"/>
              <line x1="5" y1="650" x2="1195" y2="650" stroke="#fff" stroke-width="2" stroke-dasharray="4 8"/>
              <line x1="130" y1="0" x2="130" y2="700" stroke="#fff" stroke-width="2" stroke-dasharray="8 10"/>
              <line x1="1070" y1="0" x2="1070" y2="700" stroke="#fff" stroke-width="2" stroke-dasharray="8 10"/>
            </svg>

            <svg class="grid" id="grid" viewBox="0 0 1200 700" preserveAspectRatio="none"></svg>
            <svg class="draw" id="draw" viewBox="0 0 1200 700" preserveAspectRatio="none"></svg>
            <div id="players"></div>
            <div id="ball" class="ball" title="Balón"></div>
            <div id="selectionBox" style="display:none;"></div> <!-- Recuadro de selección -->
          </div>
        </div>
        <canvas id="exportCanvas" width="1200" height="700" style="display:none"></canvas>
      </section>
    </main>

    <!-- Eliminamos el Dock Inferior (Mobile) que causaba duplicidades -->
    <!-- <footer class="dock" id="toolDock"> ... </footer> -->
  </div>
  
<script>
// La lógica de inicialización de Firebase está en el bloque <script type="module">
/* window.onload = () => {
    window.initFirebaseAndApp();
}; */

/* ---------- Constantes ---------- */
const WIDTH=1200, HEIGHT=700, GRID=24;

// Coordenadas del campo (1200x700). Para simplificar el prompt de Gemini, mapeamos el campo a un grid de 12x7.
const FIELD_GRID_W = 12;
const FIELD_GRID_H = 7;
const CELL_W = WIDTH / FIELD_GRID_W;
const CELL_H = HEIGHT / FIELD_GRID_H;

/* ---------- DOM ---------- */
const desktopSidepanel = document.getElementById('desktopSidepanel'); // Contenedor principal de controles
const boardViewport = document.getElementById('boardViewport');
const boardWrap = document.getElementById('boardWrap');
const board = document.getElementById('board');
const playersLayer = document.getElementById('players');
const draw = document.getElementById('draw');
const gridSvg = document.getElementById('grid');
const ball = document.getElementById('ball');
const exportCanvas = document.getElementById('exportCanvas');
const ctx = exportCanvas.getContext('2d');
const selectionBox = document.getElementById('selectionBox'); 
const loginModal = document.getElementById('loginModal'); // Nuevo DOM ID
const btnAuthAction = document.getElementById('btnAuthAction'); // Nuevo DOM ID
const menuOverlay = document.getElementById('menuOverlay'); // Nuevo DOM ID

// Botones de control móvil
const btnCloseMenu = document.getElementById('btnCloseMenu');
const btnMenuOpen = document.getElementById('btnMenuOpen');

/* Topbar / acciones */
const btnLandscape = document.getElementById('btnLandscape');
const btnPortrait = document.getElementById('btnPortrait');
const btnReset = document.getElementById('btnReset');
const btnSavePlay = document.getElementById('btnSavePlay');
const btnLoadPlay = document.getElementById('btnLoadPlay');
const btnExportJpg = document.getElementById('btnExportJpg');
const btnExportWebm = document.getElementById('btnExportWebm');
const btnExportMp4 = document.getElementById('btnExportMp4');


/* Dock herramientas (Desktop: en Sidepanel) */
const toolArrows = document.getElementById('toolArrows');
const toolPen = document.getElementById('toolPen');
const toolText = document.getElementById('toolText'); // NUEVO DOM ID
const strokeColor = document.getElementById('strokeColor');
const strokeWidth = document.getElementById('strokeWidth');
const dashed = document.getElementById('dashed');
// const snap = document.getElementById('snap'); // ELIMINADO
const showGrid = document.getElementById('showGrid');
const btnUndo = document.getElementById('btnUndo');
const btnClear = document.getElementById('btnClear');

/* Jugadas (Desktop) */
const playName = document.getElementById('playName');
const btnDuplicate = document.getElementById('btnDuplicate');
const playList = document.getElementById('playList');
const btnDelete = document.getElementById('btnDelete');

/* Timeline (Desktop) */
const btnRecord = document.getElementById('btnRecord');
const autoRec = document.getElementById('autoRec');
// const btnPlay = document.getElementById('btnPlay'); // ELIMINADO
// const btnPause = document.getElementById('btnPause'); // ELIMINADO
const btnPlayPause = document.getElementById('btnPlayPause'); // NUEVO
const btnStop = document.getElementById('btnStop');
const speed = document.getElementById('speed');
const scrubber = document.getElementById('scrubber');
const scrubLbl = document.getElementById('scrubLbl');

/* Asistente Gemini */
// const btnGeminiAnalyze = document.getElementById('btnGeminiAnalyze'); // MÓDULO OCULTO
// const geminiAssistantOutput = document.getElementById('geminiAssistantOutput'); // MÓDULO OCULTO

// Controles de Orientación Móvil (Ahora solo se usan para el evento, no para el valor)
const btnLandscapeMobile = document.getElementById('btnLandscapeMobile');
const btnPortraitMobile = document.getElementById('btnPortraitMobile');


// Variables de estado del tablero
let arrows=[], strokes=[], notes=[], timeline=[]; // NUEVO ARRAY NOTES
let teamConfig = { 
    // Los datos iniciales del equipo se guardan aquí (se mantienen para compatibilidad con jugadas guardadas)
    team1: { name: 'Equipo Azul', colorClass: 'team-1', hexColor: '#2f80ff' }, // blue
    team2: { name: 'Equipo Rojo', colorClass: 'team-2', hexColor: '#ff5a6b' }  // red
};
const initialPositions=[];
for(let i=1;i<=15;i++) initialPositions.push({team:'team-1', number:i, x:WIDTH*0.18,y:HEIGHT*(0.1+(i-1)*(0.8/14))});
for(let i=1;i<=15;i++) initialPositions.push({team:'team-2', number:i, x:WIDTH*0.82,y:HEIGHT*(0.1+(i-1)*(0.8/14))});
let currentBallPos={x:WIDTH/2,y:HEIGHT/2};
let selectedPlayers = new Set(); // Conjunto para almacenar los elementos DOM de los jugadores seleccionados

/* -------------------------------------------------------------------------- */
/* ---------- Funciones de Persistencia (CON FALLBACK LOCAL) ---------------- */
/* -------------------------------------------------------------------------- */

// --- NUEVA FUNCIÓN PARA HABILITAR/DESHABILITAR CONTROLES ---
function setControlsDisabled(disabled) {
    // Botones de Guardar/Eliminar (Top Bar y Side Panel)
    [btnSavePlay, btnDelete, btnRecord, btnDuplicate, btnClrTl].forEach(btn => { if(btn) btn.disabled = disabled; });
    
    // Controles de Dibujo 
    [toolArrows, toolPen, toolText, strokeColor, strokeWidth, dashed, showGrid, btnUndo, btnClear].forEach(el => { if(el) el.disabled = disabled; });
    
    // Controles de Movimiento de Jugadores/Balón (se reactivan con reInitializePlayerInteractions() si es Entrenador)
    board.style.pointerEvents = disabled ? 'none' : 'auto';
    playersLayer.style.pointerEvents = disabled ? 'none' : 'auto';
    ball.style.pointerEvents = disabled ? 'none' : 'auto';


    // SIEMPRE HABILITAR CARGAR, PLAY Y LISTAS para MODO ESPECTADOR (disabled=false)
    [btnLoadPlay, playList, btnPlayPause, btnStop, scrubber].forEach(el => { if(el) el.disabled = false; });
    
    // Habilitar botón de Reset sólo para Entrenadores
    btnReset.disabled = !window.isAuthorized;
}


function getPlayKey(name) {
    return 'rb-play-' + name.replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
}

// 1. Guardar Estado Completo (Jugada)
async function savePlay(name) {
    if (window.db && !window.isAuthorized) {
         showStatus('ERROR: No estás autorizado para guardar jugadas en la nube.', 'var(--red)');
         return;
    }

    const playId = name.replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase(); 
    const payload = { 
        name: name,
        positions: snapshotPlayers(), 
        ball: snapshotBall(),
        arrows: arrows, 
        strokes: strokes, 
        notes: notes, // NUEVO: GUARDAR NOTAS
        timeline: timeline,
        // NUEVO: Guardar la configuración de equipos (aunque esté oculta, se guarda)
        teamConfig: teamConfig,
        updatedAt: new Date().toISOString()
    };

    if (window.db) {
        // --- FIREBASE LOGIC (Cloud) ---
        if (!window.db || !name) return console.error("DB no disponible o nombre inválido.");
        try {
            // Guardamos la jugada en la colección pública (solo autorizado)
            await window.setDoc(window.doc(window.getPlayCollectionRef(), playId), payload);
            console.log(`Jugada '${name}' guardada con éxito en Firestore.`);
            showStatus('Jugada guardada en la nube!', 'var(--accent2)');
        } catch (e) {
            console.error("Error al guardar jugada en Firestore:", e);
            showStatus('Error al guardar: ' + e.message, 'var(--red)');
        }
    } else {
        // --- LOCAL STORAGE FALLBACK (Local) ---
        try {
            localStorage.setItem(getPlayKey(playId), JSON.stringify(payload));
            refreshPlayList();
            playName.value = name;
            showStatus('Jugada guardada LOCALMENTE!', 'var(--warn)');
        } catch (e) {
            console.error("Error saving to local storage:", e);
            showStatus('ERROR: Espacio local insuficiente.', 'var(--red)');
        }
    }
}

// 2. Eliminar Jugada
async function deletePlay(playId) {
    if (!playId) return;
    if (window.db && !window.isAuthorized) {
         showStatus('ERROR: No estás autorizado para eliminar jugadas.', 'var(--red)');
         return;
    }

    if (window.db) {
        // --- FIREBASE LOGIC (Cloud) ---
        try {
            await window.deleteDoc(window.doc(window.getPlayCollectionRef(), playId));
            console.log(`Jugada '${playId}' eliminada de Firestore.`);
        } catch (e) {
            console.error("Error al eliminar jugada:", e);
            showStatus('Error al eliminar: ' + e.message, 'var(--red)');
        }
    } else {
        // --- LOCAL STORAGE FALLBACK (Local) ---
        localStorage.removeItem(getPlayKey(playId));
        refreshPlayList();
        showStatus('Jugada eliminada localmente.', 'var(--accent)');
    }
}

// Función para aplicar la configuración de nombres a los jugadores en el DOM
function applyTeamConfigToPlayers() {
    [...playersLayer.children].forEach(el => {
        const teamKey = el.dataset.team === 'team-1' ? 'team1' : 'team2';
        const teamData = teamConfig[teamKey];
        
        // Asigna la clase CSS correcta ('team-1' o 'team-2') al jugador
        el.className = `player ${teamData.colorClass}`;
    });
}

// 3. Cargar Jugada Seleccionada (Unificada)
function loadPlay(playId) {
    // Solo usamos playList (desktop) como referencia
    const listToUse = playList;
    const option = Array.from(listToUse.options).find(opt => opt.value === playId);

    if (!option || !option.dataset.payload) {
        showStatus('Jugada no encontrada en la lista.', 'var(--red)');
        return;
    }

    try {
        const data = JSON.parse(option.dataset.payload);
        
        // SINCRONIZACIÓN DE CONFIGURACIÓN DE EQUIPOS
        if (data.teamConfig) {
            teamConfig = data.teamConfig;
        }
        
        // Sincronizar campos de texto
        playName.value = data.name || playId;
        
        // 1. Cargar posiciones de jugadores
        playersLayer.innerHTML = '';
        selectedPlayers.clear(); // Limpiar selección al cargar
        (data.positions || []).forEach(p => {
            const el = document.createElement('div');
            // Usar p.team que ahora debe ser 'team-1' o 'team-2'
            el.className = `player ${p.team}`; 
            el.textContent = p.number;
            el.dataset.team = p.team; 
            el.dataset.number = p.number;
            el.style.left = p.x + 'px'; el.style.top = p.y + 'px';
            // IMPORTANTE: enableDragPlayer solo permite arrastrar si está autorizado (lógica dentro de la función)
            enableDragPlayer(el, () => { if (autoRec.checked) recordFrame(); }); 
            playersLayer.appendChild(el);
        });
        applyUprightTransforms();
        applyTeamConfigToPlayers(); // Aplicar nombres/clases después de cargar DOM

        // 2. Cargar balón
        placeBall(data.ball.x, data.ball.y);
        
        // 3. Cargar dibujos y timeline
        arrows = data.arrows || [];
        strokes = data.strokes || [];
        notes = data.notes || []; // NUEVO: CARGAR NOTAS
        timeline = Array.isArray(data.timeline) ? data.timeline : [];
        
        renderDraw(); 
        updateScrub(); 
        if (timeline.length) gotoFrame(0);

        showStatus(`Jugada '${data.name}' cargada con éxito.`, 'var(--accent)');

    } catch (e) {
        console.error("Error al parsear/cargar jugada:", e);
        showStatus('Error al cargar la jugada.', 'var(--red)');
    }
}

function populatePlayList(jugadas) {
    const listToUse = playList;
    if (!listToUse) return; // FIX: Null Check
    listToUse.innerHTML = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = jugadas.length > 0 ? '--- Seleccionar Jugada ---' : 'No hay jugadas guardadas';
    placeholder.disabled = true;
    placeholder.selected = true;
    listToUse.appendChild(placeholder);
    
    jugadas.forEach(j => {
        const opt = document.createElement('option');
        opt.value = j.id;
        opt.textContent = j.name;
        opt.dataset.payload = j.payload;
        listToUse.appendChild(opt);
    });

    // La lista y el botón Cargar SIEMPRE deben estar habilitados para el espectador
    listToUse.disabled = false;

    if (btnLoadPlay) btnLoadPlay.disabled = false; // Solo el botón de cargar es necesario
}

// 4. Suscripción/Refresco de la lista
let unsubscribePlays = null;
function refreshPlayList() {
    if (window.db) {
        // --- FIREBASE LOGIC (Cloud) ---
        if (unsubscribePlays) unsubscribePlays();
        
        // FIX: La lista y el botón Cargar SIEMPRE deben estar habilitados si la DB está viva
        if (playList) playList.disabled = false;
        if (btnLoadPlay) btnLoadPlay.disabled = false;
        
        // Verificamos que la DB esté inicializada antes de intentar el onSnapshot
        if (!window.db || !window.auth) {
            if (playList) {
                playList.innerHTML = '<option value="">Error de conexión DB</option>';
                playList.disabled = true;
            }
            return;
        } 
        
        // La consulta es a la colección pública
        const q = window.query(window.getPlayCollectionRef());

        unsubscribePlays = window.onSnapshot(q, (snapshot) => {
            const jugadas = [];
            snapshot.forEach((doc) => {
                const data = doc.data();
                jugadas.push({ id: doc.id, name: data.name || doc.id, payload: JSON.stringify(data) });
            });
            jugadas.sort((a, b) => a.name.localeCompare(b.name));
            populatePlayList(jugadas);
        }, (error) => {
            console.error("Error al escuchar jugadas:", error);
            showStatus('Error al cargar la lista de jugadas desde la nube. VERIFICA REGLAS DE LECTURA DE FIRESTORE.', 'var(--red)');
        });
    } else {
        // --- LOCAL STORAGE FALLBACK (Local) ---
        if (unsubscribePlays) { unsubscribePlays(); unsubscribePlays = null; } // Asegurar que no hay listeners de Firebase

        const keys = Object.keys(localStorage).filter(k => k.startsWith('rb-play-')).sort();
        const jugadas = [];

        keys.forEach(k => {
            try {
                const data = JSON.parse(localStorage.getItem(k));
                const id = k.replace('rb-play-', '');
                jugadas.push({ id: id, name: data.name || id, payload: JSON.stringify(data) });
            } catch {}
        });
        
        jugadas.sort((a, b) => a.name.localeCompare(b.name));
        populatePlayList(jugadas);
    }
}
/* -------------------------------------------------------------------------- */


/* ---------- Eventos de Persistencia (Mapeo a funciones unificadas) ---------- */

// Eventos para Desktop
btnSavePlay.addEventListener('click', async () => {
    const name = (playName.value || '').trim(); 
    if(!name) { showStatus('¡Poné un nombre para guardar la jugada!', 'var(--warn)'); return; }
    await savePlay(name);
});

btnDelete.addEventListener('click', async () => {
    const playId = playList.value; 
    if (!playId) { showStatus('Elegí una jugada para eliminar.', 'var(--warn)'); return; }
    if (!confirm(`¿Estás seguro de eliminar la jugada "${playList.options[playList.selectedIndex].textContent}"?`)) return;
    await deletePlay(playId);
});

btnLoadPlay.addEventListener('click', () => {
    if (!playList.value) { showStatus('Elegí una jugada del selector.', 'var(--warn)'); return; }
    loadPlay(playList.value);
});

playList.addEventListener('change', () => { 
    if (!playList.options[playList.selectedIndex]) return;
    selectedOption = playList.options[playList.selectedIndex];
    playName.value = selectedOption.textContent;
});

// Eventos para Mobile (Sincronización)
if (document.getElementById('playNameMobile')) document.getElementById('playNameMobile').addEventListener('input', (e) => { playName.value = e.target.value; });
if (document.getElementById('btnLoadPlayMobile')) document.getElementById('btnLoadPlayMobile').addEventListener('click', () => { btnLoadPlay.click(); });
if (document.getElementById('playListMobile')) document.getElementById('playListMobile').addEventListener('change', (e) => { playList.value = e.target.value; playName.value = e.target.options[e.target.selectedIndex].textContent; });
if (document.getElementById('btnDeleteMobile')) document.getElementById('btnDeleteMobile').addEventListener('click', async () => { btnDelete.click(); });


/* -------------------------------------------------------------------------- */
/* ---------- Lógica de Autenticación (Login/Logout) ---------- */
/* -------------------------------------------------------------------------- */

// CORRECCIÓN CRÍTICA: Reaplicar la lógica de drag and drop a los jugadores 
// para habilitarlos si el usuario acaba de iniciar sesión como Entrenador.
function reInitializePlayerInteractions() {
    [...playersLayer.children].forEach(el => {
        // Asegurarse de que los players recién cargados tengan la lógica de drag activa si es autorizado
        enableDragPlayer(el, (isGroupMove) => { if (!isGroupMove && autoRec.checked) recordFrame(); });
    });
    enableDragBall(()=>{ if (autoRec.checked) recordFrame(); });
    enableSelectionBox();
}

// Función para actualizar el botón de acción de Auth
function updateAuthButton(isLoggedIn) {
    if (isLoggedIn) {
        btnAuthAction.textContent = 'Cerrar Sesión';
        btnAuthAction.classList.remove('primary');
        btnAuthAction.onclick = handleLogout;
    } else {
        btnAuthAction.textContent = 'Iniciar Sesión';
        btnAuthAction.classList.add('primary');
        btnAuthAction.onclick = () => loginModal.style.display = 'grid';
    }
}

// Evento: Iniciar Sesión
const loginEmail = document.getElementById('loginEmail');
const loginPassword = document.getElementById('loginPassword');
const btnLogin = document.getElementById('btnLogin');
const btnCloseLogin = document.getElementById('btnCloseLogin');
const loginMessage = document.getElementById('loginMessage');

btnLogin.addEventListener('click', async () => {
    const email = loginEmail.value;
    const password = loginPassword.value;
    
    if (!email || !password) {
        loginMessage.textContent = 'Ingresa email y contraseña.';
        return;
    }
    
    btnLogin.disabled = true;
    loginMessage.textContent = 'Iniciando sesión...';

    try {
        await window.signInWithEmailAndPassword(window.auth, email, password);
        // Si tiene éxito, el onAuthStateChanged se disparará, actualizando la UI.
        loginMessage.textContent = ''; // Limpiar mensaje de login

    } catch (error) {
        console.error("Login failed:", error.code, error.message);
        // Mostrar mensaje de error más legible
        let errorMessage = error.message;
        if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
            errorMessage = 'Credenciales incorrectas.';
        } else if (error.code === 'auth/invalid-email') {
            errorMessage = 'Formato de email inválido.';
        } else if (error.code === 'auth/operation-not-allowed') {
            errorMessage = 'La autenticación con email/password no está habilitada en tu proyecto de Firebase.';
        }
        loginMessage.textContent = `Error: ${errorMessage.replace('Firebase: Error ', '').replace(/\(.*\)/, '')}`;
    } finally {
        btnLogin.disabled = false;
    }
});

// Evento: Cerrar Modal (Solo si ya está logueado, de lo contrario, no puede cerrar)
btnCloseLogin.addEventListener('click', () => {
    // Si el usuario no está logueado, forzamos la visualización del modal
    if (window.auth && window.auth.currentUser) {
        loginModal.style.display = 'none';
        loginMessage.textContent = '';
        loginEmail.value = '';
        loginPassword.value = '';
    } else {
        showStatus('Debes iniciar sesión para continuar.', 'var(--red)');
    }
});

// Evento: Cerrar Sesión
async function handleLogout() {
    if (window.db) {
        try {
            await window.signOut(window.auth);
            showStatus('Sesión cerrada. Iniciando modo Espectador...', 'var(--accent)');
        } catch (error) {
            showStatus('Error al cerrar sesión.', 'var(--red)');
            console.error("Logout failed:", error);
        }
    } else {
        // En modo local, solo hacemos un "reset" visual.
        showStatus('Modo local: Cierre de sesión simulado.', 'var(--accent)');
        window.location.reload();
    }
}


/* ---------- Utilidades Generales de UI/Estado ---------- */

function showStatus(message, color='var(--accent)'){
    const statusDiv = document.createElement('div');
    statusDiv.className = 'status-message';
    statusDiv.textContent = message;
    statusDiv.style.cssText = `
        position: fixed; top: 70px; right: 20px;
        background: ${color}; color: var(--bg); padding: 10px 15px;
        border-radius: 8px; z-index: 9999; opacity: 0;
        transition: opacity 0.5s ease-in-out;
    `;
    document.body.appendChild(statusDiv);
    
    setTimeout(() => { statusDiv.style.opacity = 1; }, 10);
    setTimeout(() => { statusDiv.style.opacity = 0; }, 3000);
    setTimeout(() => { statusDiv.remove(); }, 3500);
}


/* ------------------------------------------------------------------ */
/* ---------- Lógica de Layout y Adaptabilidad (REVISADA) ---------- */
/* ------------------------------------------------------------------ */
let layout={mode:'landscape', scale:1, tx:0, ty:0};
let forcePortrait=false;

function setSegActive(segBtn, otherBtn){
  if(segBtn) segBtn.classList.add('active');
  if(otherBtn) otherBtn.classList.remove('active');
}

btnLandscape.addEventListener('click', ()=>{ forcePortrait=false; setSegActive(btnLandscape,btnPortrait); fitBoard(); });
btnPortrait.addEventListener('click', ()=>{ forcePortrait=true; setSegActive(btnPortrait,btnLandscape); fitBoard(); });

function isPortraitLike(){
  if (forcePortrait) return true;
  const mq=window.matchMedia('(orientation: portrait)');
  return (mq && mq.matches) || (window.innerHeight>window.innerWidth);
}

function applyUprightTransforms(){
  // Esta función gira los jugadores si el campo está rotado (modo portrait)
  const rotatePlayers=(layout.mode==='portrait');
  [...playersLayer.children].forEach(el=>{
    // Rotamos -90deg para compensar la rotación de 90deg del board-wrap
    el.style.transform = rotatePlayers
      ? 'translate(-50%,-50%) rotate(-90deg)' 
      : 'translate(-50%,-50%)';
  });
}

function fitBoard(){
  const vp=boardViewport.getBoundingClientRect();
  const availW=vp.width, availH=vp.height;

  // DIMENSIONES BASE DEL CAMPO (1200 x 700)
  const baseW = WIDTH;
  const baseH = HEIGHT;

  let currentW, currentH; // Dimensiones del campo tal como se verá en el viewport
  let scale;

  // LÓGICA DE DETECCIÓN DE MÓVIL/ESCRITORIO
  const isMobile = window.innerWidth <= 999;
  
  // FIX: Forzar Portrait en móvil
  if (isMobile) {
      forcePortrait = true; 
  } else {
      forcePortrait = false; // Permitir que la detección normal de desktop funcione
  }
  
  if (isMobile || isPortraitLike()){
    // Orientación Vertical (Retrato)
    layout.mode='portrait';
    
    // El campo rotado 90 grados tiene dimensiones HxW (700 x 1200)
    currentW = baseH; // 700
    currentH = baseW; // 1200
    
    // Escala el campo rotado para que se ajuste
    scale = Math.min(availW/currentW, availH/currentH);

    layout.scale=scale;
    
    // Aplicamos transformación: Rotación y escalado alrededor del centro (50% 50%)
    boardWrap.style.transform=`rotate(90deg) scale(${scale})`;
    boardWrap.style.transformOrigin='center center'; // Rotación y escala desde el centro
    
    // Centrado de coordenadas
    const scaledRotatedW = baseH * scale;
    const scaledRotatedH = baseW * scale;

    layout.tx = (availW - scaledRotatedW) / 2; // Offset X del rectangulo rotado y escalado
    layout.ty = (availH - scaledRotatedH) / 2; // Offset Y del rectangulo rotado y escalado

    // Sincronizar botones de orientación
    setSegActive(btnPortrait, btnLandscape);
    // Asignar el estado al botón correcto en el menú desplegable (si existe)
    if (document.getElementById('btnPortraitMobile')) setSegActive(document.getElementById('btnPortraitMobile'), document.getElementById('btnLandscapeMobile'));
    
  } else {
    // Orientación Horizontal (Paisaje)
    layout.mode='landscape';
    currentW = baseW;
    currentH = baseH;
    
    // Escala el campo para que se ajuste al 100% del contenedor
    scale = Math.min(availW/currentW, availH/currentH);
    
    layout.scale=scale;
    
    // Centrado: calcula la traducción (tx, ty) para centrar el campo escalado
    layout.tx = (availW - currentW * scale) / 2;
    layout.ty = (availH - currentH * scale) / 2;
    
    // Aplica transformación: SOLO escalado
    boardWrap.style.transform=`scale(${scale})`;
    boardWrap.style.transformOrigin='center center'; // Centrado desde el centro para flexbox
    
    // Sincronizar botones de orientación
    setSegActive(btnLandscape, btnPortrait);
    if (document.getElementById('btnLandscapeMobile')) setSegActive(document.getElementById('btnLandscapeMobile'), document.getElementById('btnPortraitMobile'));

  }

  applyUprightTransforms();
}

window.addEventListener('resize', fitBoard);
window.addEventListener('orientationchange', fitBoard);


/* ---------- Utilidades coordenadas (CORREGIDA) ---------- */
function clientToBoard(e){
  const vp=boardViewport.getBoundingClientRect();
  const cx=e.clientX - vp.left;
  const cy=e.clientY - vp.top;
  
  if (layout.mode==='portrait'){
    // FIX: Ahora que usamos flexbox y transform-origin:center center,
    // el punto 0,0 del tablero rotado se mueve.
    // 1. Recalcular las coordenadas relativas al centro del viewport.
    const centerX = vp.width / 2;
    const centerY = vp.height / 2;

    const px = cx - centerX;
    const py = cy - centerY;

    // 2. Deshacer la rotación de 90 grados (CW) en el sistema de coordenadas.
    // x_rot = y_orig (invertido)
    // y_rot = x_orig
    // Deshacer (CCW -90deg):
    // x_board = py (mapeado a Y)
    // y_board = -px (mapeado a X, y luego invertido)
    
    // Corregimos la asignación de signos para el cálculo del punto de clic/selección
    const x_board_scaled = py;
    const y_board_scaled = -px;

    // 3. Aplicar la escala y mover al origen (0,0) del tablero (1200x700).
    // El eje X del tablero (1200) es el largo. El Y (700) es el ancho.
    const x_board = (WIDTH / 2) + (x_board_scaled / layout.scale);
    const y_board = (HEIGHT / 2) + (y_board_scaled / layout.scale);

    return { x:clamp(x_board,0,WIDTH), y:clamp(y_board,0,HEIGHT) };
    
  } else {
    // Modo horizontal
    // Centrado de Flexbox: Coordenadas relativas al 0,0 del viewport.
    const scaledW = WIDTH * layout.scale;
    const scaledH = HEIGHT * layout.scale;
    
    const x = (cx - (vp.width - scaledW) / 2) / layout.scale;
    const y = (cy - (vp.height - scaledH) / 2) / layout.scale;

    return { x:clamp(x,0,WIDTH), y:clamp(y,0,HEIGHT) };
  }
}

function deltaToBoard(dxClient, dyClient){
  if (layout.mode==='portrait'){
    // Movimiento basado en la rotación del viewport (90 deg CW).
    // dx_board = +dy_client
    // dy_board = -dx_client
    return { 
        dx: dyClient / layout.scale,  
        dy: -dxClient / layout.scale 
    };
  }else{
    return { dx: dxClient / layout.scale, dy: dyClient / layout.scale };
  }
}

function snapVal(v){ return Math.round(v/GRID)*GRID; }
function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }
function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.hypot(dx,dy); } // CORRECCIÓN BUG: dy = ay - by
function centerOf(el){ return { x:parseFloat(el.style.left)||0, y:parseFloat(el.style.top)||0 } }
function rectIntersect(rect1, rect2) {
    return rect1.left < rect2.right &&
           rect1.right > rect2.left &&
           rect1.top < rect2.bottom &&
           rect1.bottom > rect2.top;
}
function clearPlayerSelection() {
    selectedPlayers.forEach(el => el.classList.remove('selected'));
    selectedPlayers.clear();
}

/* ---------- Grilla (Copia de la original) ---------- */
function renderGrid(){
  gridSvg.innerHTML='';
  if (!showGrid.checked) { gridSvg.classList.remove('on'); return; }
  gridSvg.classList.add('on');
  const g=document.createElementNS('http://www.w3.org/2000/svg','g');
  for(let x=GRID;x<WIDTH;x+=GRID){
    const l=document.createElementNS('http://www.w3.org/2000/svg','line');
    l.setAttribute('x1',x); l.setAttribute('y1',0); l.setAttribute('x2',x); l.setAttribute('y2',HEIGHT);
    l.setAttribute('stroke','rgba(255,255,255,.08)'); l.setAttribute('stroke-width','1');
    g.appendChild(l);
  }
  for(let y=GRID;y<HEIGHT;y+=GRID){
    const l=document.createElementNS('http://www.w3.org/2000/svg','line');
    l.setAttribute('x1',0); l.setAttribute('y1',y); l.setAttribute('x2',WIDTH); l.setAttribute('y2',y);
    l.setAttribute('stroke','rgba(255,255,255,.08)'); l.setAttribute('stroke-width','1');
    g.appendChild(l);
  }
  gridSvg.appendChild(g);
}
showGrid.addEventListener('change', renderGrid);

/* ---------- Jugadores y balón (Modificado para usar currentBallPos) ---------- */
function createPlayers(){
  playersLayer.innerHTML='';
  selectedPlayers.clear(); // Limpiar selección al reiniciar
  initialPositions.forEach(p=>{
    const el=document.createElement('div');
    // Usamos el colorClass definido en teamConfig
    const teamData = p.team === 'team-1' ? teamConfig.team1 : teamConfig.team2;
    el.className=`player ${teamData.colorClass}`; 
    el.textContent=p.number;
    el.dataset.team=p.team; 
    el.dataset.number=p.number;
    el.style.left=p.x+'px'; el.style.top=p.y+'px';
    enableDragPlayer(el, (isGroupMove)=>{ if (!isGroupMove && autoRec.checked) recordFrame(); });
    playersLayer.appendChild(el);
  });
  applyUprightTransforms();
}

function placeBall(x=WIDTH/2,y=HEIGHT/2){
  currentBallPos.x=x; currentBallPos.y=y;
  ball.style.left=x+'px'; ball.style.top=y+'px';
  ball.style.transform='translate(-50%,-50%) rotate(-15deg)';
}

function ballOverPlayer(playerEl, threshold=28){
  const b=centerOf(ball), p=centerOf(playerEl);
  return dist(b.x,b.y,p.x,p.y)<threshold;
}

/* Drag jugador (arrastra balón si estaba encima) (MODIFICADO para movimiento masivo) */
function enableDragPlayer(playerEl, onDrop){
  let pid=null, sx=0, sy=0, ox=0, oy=0;
  let lockBall=false, offX=0, offY=0;
  let isGroupMove = false; // Flag para movimiento de grupo
  let playerOffsets = []; // Almacena offsets iniciales para el grupo
  
  // Si el usuario no está autorizado, no debe poder arrastrar
  if (window.db && !window.isAuthorized) return;

  const down=e=>{
    pid=e.pointerId; playerEl.setPointerCapture(pid); e.preventDefault();
    sx=e.clientX; sy=e.clientY;
    ox=parseFloat(playerEl.style.left)||0;
    oy=parseFloat(playerEl.style.top)||0;

    // Si el jugador no estaba seleccionado, borra la selección anterior
    if (!playerEl.classList.contains('selected')) {
        clearPlayerSelection();
        playerEl.classList.add('selected');
        selectedPlayers.add(playerEl);
    }
    
    isGroupMove = selectedPlayers.has(playerEl) && selectedPlayers.size > 1;

    // Si es movimiento de grupo, precalculamos offsets
    if (isGroupMove) {
        playerOffsets = Array.from(selectedPlayers).map(el => ({
            el: el,
            offsetX: parseFloat(el.style.left) - ox,
            offsetY: parseFloat(el.style.top) - oy,
            initialX: parseFloat(el.style.left),
            initialY: parseFloat(el.style.top),
        }));
    }

    lockBall=ballOverPlayer(playerEl);
    if (lockBall){
      const p0={x:ox,y:oy}, b0=centerOf(ball);
      offX=b0.x-p0.x; offY=b0.y-p0.y;
    }

    const move=ev=>{
      if (ev.pointerId!==pid) return; ev.preventDefault();
      const {dx,dy}=deltaToBoard(ev.clientX-sx, ev.clientY-sy);
      
      let nx_main=clamp(ox+dx,0,WIDTH), ny_main=clamp(oy+dy,0,HEIGHT);
      
      if (isGroupMove) {
          // Mover todo el grupo
          playerOffsets.forEach(p => {
              let nx_p = clamp(p.initialX + dx, 0, WIDTH);
              let ny_p = clamp(p.initialY + dy, 0, HEIGHT);
              p.el.style.left = nx_p + 'px';
              p.el.style.top = ny_p + 'px';
          });
          // El jugador principal (el arrastrado) ya se mueve con el grupo,
          // pero el cálculo de bloqueo de balón sigue el arrastrado.
          playerEl.style.left = nx_main + 'px';
          playerEl.style.top = ny_main + 'px';

      } else {
          // Movimiento de un solo jugador
          playerEl.style.left=nx_main+'px'; playerEl.style.top=ny_main+'px';
      }

      if (lockBall){
        const bx=clamp(nx_main+offX,0,WIDTH), by=clamp(ny_main+offY,0,HEIGHT);
        placeBall(bx,by);
      }
    };
    const up=ev=>{
      if (ev.pointerId!==pid) return;
      try{playerEl.releasePointerCapture(pid);}catch{}
      document.removeEventListener('pointermove',move);
      document.removeEventListener('pointerup',up);
      
      // Aplicar Snap (la lógica es compleja si no usamos las posiciones iniciales)
      // CORRECCIÓN: Lógica de snap eliminada (punto 3)
      /* if (snap.checked){
          // ... (código de snap antiguo)
      } */
      
      onDrop && onDrop(isGroupMove);
    };
    document.addEventListener('pointermove',move,{passive:false});
    document.addEventListener('pointerup',up,{passive:false});
  };
  playerEl.addEventListener('pointerdown',down,{passive:false});
  playerEl.ondragstart=()=>false;
}

/* Drag balón: con línea de pase (Modificado para usar placeBall) */
function enableDragBall(onDrop){
  let pid=null, sx=0, sy=0, ox=0, oy=0, passer=null;
  
  // Si el usuario no está autorizado, no debe poder arrastrar
  if (window.db && !window.isAuthorized) return;

  const down=e=>{
    pid=e.pointerId; ball.setPointerCapture(pid); e.preventDefault();
    sx=e.clientX; sy=e.clientY; ox=currentBallPos.x; oy=currentBallPos.y;
    
    // Al tocar el balón, se borra la selección de jugadores
    clearPlayerSelection();

    // detectar jugador “pasador” (si el balón iniciaba encima)
    const b0=centerOf(ball);
    passer=(()=>{
      let best=null,bestD=Infinity;
      for(const el of playersLayer.children){
        const p=centerOf(el), d=dist(b0.x,b0.y,p.x,p.y);
        if (d<28 && d<bestD){ best=el; bestD=d; }
      }
      return best;
    })();
    if (passer){ const p=centerOf(passer); showPassPreview(p.x,p.y,b0.x,b0.y); }

    const move=ev=>{
      if (ev.pointerId!==pid) return; ev.preventDefault();
      const {dx,dy}=deltaToBoard(ev.clientX-sx, ev.clientY-sy);
      let nx=clamp(ox+dx,0,WIDTH), ny=clamp(oy+dy,0,HEIGHT);
      placeBall(nx,ny);
      if (passer){ const p=centerOf(passer); showPassPreview(p.x,p.y,nx,ny); }
    };
    const up=ev=>{
      if (ev.pointerId!==pid) return;
      try{ball.releasePointerCapture(pid);}catch{}
      document.removeEventListener('pointermove',move);
      document.removeEventListener('pointerup',up);
      // CORRECCIÓN: Lógica de snap eliminada (punto 3)
      /* if (snap.checked){
        placeBall(snapVal(currentBallPos.x), snapVal(currentBallPos.y));
      } */
      hidePassPreview();
      onDrop && onDrop();
    };
    document.addEventListener('pointermove',move,{passive:false});
    document.addEventListener('pointerup',up,{passive:false});
  };
  ball.addEventListener('pointerdown',down,{passive:false});
  ball.ondragstart=()=>false;
}

/* ---------- Lógica de Selección Masiva (Nueva Función) ---------- */
function enableSelectionBox() {
    let pid = null, startBoard = null, startClient = null;
    
    // Si el usuario no está autorizado, no debe poder usar el recuadro de selección.
    if (window.db && !window.isAuthorized) return;

    const down = (e) => {
        // Solo activa el recuadro si no se está tocando un jugador o el balón,
        // y si la tecla Shift está pulsada (para desktop) O si es un toque (para móvil).
        const isPlayerOrBall = e.target.closest('.player') || e.target.closest('#ball');
        const isShiftDown = e.shiftKey;
        
        if (isPlayerOrBall || tool !== 'arrows') { 
            // Si tocamos un elemento movible o no estamos en modo Flechas, no activamos el recuadro.
            return;
        }
        
        // Si ya estamos dibujando una flecha/lápiz, no permitimos el recuadro de selección.
        if (drawingArrow || drawingStroke) return;

        // Limpiar selección anterior al iniciar un nuevo recuadro
        clearPlayerSelection();

        pid = e.pointerId; 
        board.setPointerCapture(pid); 
        e.preventDefault();
        
        // **INICIO DE CORRECCIÓN PARA EL RECUAEDRO EN MODO PORTRAIT**
        // Obtenemos las coordenadas del tablero para el punto de inicio del clic.
        startBoard = clientToBoard(e); 
        
        selectionBox.style.left = startBoard.x + 'px';
        selectionBox.style.top = startBoard.y + 'px';
        selectionBox.style.width = '0';
        selectionBox.style.height = '0';
        selectionBox.style.display = 'block';

        board.addEventListener('pointermove', move);
        board.addEventListener('pointerup', up);
    };

    const move = (e) => {
        if (e.pointerId !== pid) return;
        e.preventDefault();

        const currentBoard = clientToBoard(e); // Punto actual en coordenadas del tablero
        
        // Calcular el rectángulo en coordenadas del tablero (1200x700)
        // Usamos Math.min/max para manejar el arrastre en cualquier dirección
        const left = Math.min(startBoard.x, currentBoard.x);
        const top = Math.min(startBoard.y, currentBoard.y);
        const right = Math.max(startBoard.x, currentBoard.x);
        const bottom = Math.max(startBoard.y, currentBoard.y);
        
        const width = right - left;
        const height = bottom - top;

        selectionBox.style.left = left + 'px';
        selectionBox.style.top = top + 'px';
        selectionBox.style.width = width + 'px';
        selectionBox.style.height = height + 'px';

        // Detectar jugadores dentro del recuadro
        const selectionRect = { left: left, top: top, right: right, bottom: bottom };
        
        // Limpiar la clase 'selected' de todos los jugadores si no están en la selección
        playersLayer.querySelectorAll('.player').forEach(playerEl => {
            const pX = parseFloat(playerEl.style.left);
            const pY = parseFloat(playerEl.style.top);
            
            // Margen de 20px (radio del jugador) para detectar colisión
            const playerRect = { 
                left: pX - 20, 
                top: pY - 20, 
                right: pX + 20, 
                bottom: pY + 20 
            };
            
            if (rectIntersect(selectionRect, playerRect)) {
                playerEl.classList.add('selected');
                selectedPlayers.add(playerEl);
            } else {
                playerEl.classList.remove('selected');
                selectedPlayers.delete(playerEl);
            }
        });
    };

    const up = (e) => {
        if (e.pointerId !== pid) return;
        try{board.releasePointerCapture(pid);}catch{}
        board.removeEventListener('pointermove', move);
        board.removeEventListener('pointerup', up);

        selectionBox.style.display = 'none';
        pid = null;
        startBoard = null;
        startClient = null;
    };

    board.addEventListener('pointerdown', down);
}
/* -------------------------------------------------------------------------- */


/* ---------- Pase (línea punteada temporal) (Copia de la original) ---------- */
function showPassPreview(x1,y1,x2,y2){
  let line=draw.querySelector('#passPreview');
  if (!line){
    line=document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('id','passPreview');
    line.setAttribute('stroke','#fff'); line.setAttribute('stroke-width','3');
    line.setAttribute('stroke-dasharray','10 8'); line.setAttribute('vector-effect','non-scaling-stroke');
    draw.appendChild(line);
  }
  line.setAttribute('x1',x1); line.setAttribute('y1',y1);
  line.setAttribute('x2',x2); line.setAttribute('y2',y2);
}
function hidePassPreview(){ const l=draw.querySelector('#passPreview'); if(l) l.remove(); }

/* ---------- Dibujo (flechas / lápiz / texto) ---------- */
let tool='arrows';
const setTool = (newTool, targetButton) => {
    tool = newTool;
    clearPlayerSelection(); // Limpiar selección al cambiar de herramienta
    
    // Desactivar todos los botones de herramienta
    [toolArrows, toolPen, toolText, document.getElementById('toolArrowsMobile'), document.getElementById('toolPenMobile'), document.getElementById('toolTextMobile')].forEach(btn => {
        if (btn) btn.classList.remove('active');
    });
    
    // Activar el botón correcto (se usan los IDs de escritorio y se replican en móvil si existen)
    if (newTool === 'arrows') {
        if(toolArrows) toolArrows.classList.add('active');
        if(document.getElementById('toolArrowsMobile')) document.getElementById('toolArrowsMobile').classList.add('active');
    } else if (newTool === 'pen') {
        if(toolPen) toolPen.classList.add('active');
        if(document.getElementById('toolPenMobile')) document.getElementById('toolPenMobile').classList.add('active');
    } else if (newTool === 'text') {
        if(toolText) toolText.classList.add('active');
        if(document.getElementById('toolTextMobile')) document.getElementById('toolTextMobile').classList.add('active');
    }
};

if (toolArrows) toolArrows.addEventListener('click',()=>{ setTool('arrows'); closeMobileMenu(); });
if (toolPen) toolPen.addEventListener('click',()=>{ setTool('pen'); closeMobileMenu(); });
if (toolText) toolText.addEventListener('click',()=>{ setTool('text'); closeMobileMenu(); }); // NUEVO EVENTO

// Eventos de botones de control móvil (solo necesitan el setTool y cerrar menú)
if (document.getElementById('btnLandscapeMobile')) document.getElementById('btnLandscapeMobile').addEventListener('click', ()=>{ forcePortrait=false; setSegActive(document.getElementById('btnLandscapeMobile'), document.getElementById('btnPortraitMobile')); fitBoard(); closeMobileMenu(); });
if (document.getElementById('btnPortraitMobile')) document.getElementById('btnPortraitMobile').addEventListener('click', ()=>{ forcePortrait=true; setSegActive(document.getElementById('btnPortraitMobile'), document.getElementById('btnLandscapeMobile')); fitBoard(); closeMobileMenu(); });

let drawingArrow=false, startPt=null, drawingStroke=false, currentStroke=null;

function ensureDefs(){
  if (draw.querySelector('defs')) return;
  const defs=document.createElementNS('http://www.w3.org/2000/svg','defs');
  const mk=(id,color)=>{
    const m=document.createElementNS('http://www.w3.org/2000/svg','marker');
    m.setAttribute('id',id); m.setAttribute('markerWidth','10'); m.setAttribute('markerHeight','10');
    m.setAttribute('refX','9'); m.setAttribute('refY','5'); m.setAttribute('orient','auto');
    const poly=document.createElementNS('http://www.w3.org/2000/svg','polygon');
    poly.setAttribute('points','0 0, 10 5, 0 10'); poly.setAttribute('fill',color);
    m.appendChild(poly); defs.appendChild(m);
  };
  mk('awh','#ffffff'); mk('agr','#35d07f'); mk('abl','#2f80ff'); mk('ard','#ff5a6b'); mk('ayl','#ffd400');
  draw.appendChild(defs);
}
function markerId(c){ return ({'#ffffff':'awh','#35d07f':'agr','#2f80ff':'abl','#ff5a6b':'ard','#ffd400':'ayl'})[c]||'ayl'; }

function renderDraw(){
  ensureDefs();
  const defs=draw.querySelector('defs');
  // Limpiar elementos de dibujo previos (flechas, trazos, notas)
  [...draw.childNodes].forEach(n=>{ if(n!==defs && n.id!=='passPreview') draw.removeChild(n); });
  
  // 1. Renderizar Trazos (Strokes)
  strokes.forEach(s=>{
    const pl=document.createElementNS('http://www.w3.org/2000/svg','polyline');
    pl.setAttribute('fill','none');
    pl.setAttribute('stroke', s.color||'#ffd400');
    pl.setAttribute('stroke-width', s.width||5);
    if (s.dashed) pl.setAttribute('stroke-dasharray','8 8');
    pl.setAttribute('vector-effect','non-scaling-stroke');
    pl.setAttribute('points', s.points.join(' '));
    draw.insertBefore(pl, draw.querySelector('#passPreview')||null);
  });
  
  // 2. Renderizar Flechas (Arrows)
  arrows.forEach(a=>{
    const ln=document.createElementNS('http://www.w3.org/2000/svg','line');
    ln.setAttribute('x1',a.x1); ln.setAttribute('y1',a.y1); ln.setAttribute('x2',a.x2); ln.setAttribute('y2',a.y2);
    ln.setAttribute('stroke',a.color||'#ffd400'); ln.setAttribute('stroke-width',a.width||5);
    if (a.dashed) ln.setAttribute('stroke-dasharray','8 8');
    ln.setAttribute('marker-end',`url(#${markerId(a.color||'#ffd400')})`);
    ln.setAttribute('vector-effect','non-scaling-stroke');
    draw.insertBefore(ln, draw.querySelector('#passPreview')||null);
  });

  // 3. Renderizar Notas de Texto (Notes)
  notes.forEach((n, index) => {
    const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    txt.setAttribute('x', n.x);
    txt.setAttribute('y', n.y);
    txt.setAttribute('fill', n.color || '#ffffff');
    txt.setAttribute('font-size', '18');
    txt.setAttribute('font-weight', '700');
    txt.setAttribute('text-anchor', 'middle');
    txt.setAttribute('dominant-baseline', 'middle');
    txt.setAttribute('stroke', '#000');
    txt.setAttribute('stroke-width', '0.5');
    txt.textContent = n.text;
    draw.insertBefore(txt, draw.querySelector('#passPreview') || null);
  });
}

// Helper para obtener el valor del control activo (SOLO DESKTOP AHORA)
function getActiveToolColor() { return strokeColor.value; }
function getActiveToolWidth() { return parseInt(strokeWidth.value, 10) || 5; }
function getActiveDashed() { return dashed.checked; }

board.addEventListener('pointerdown',e=>{
  if (e.target.closest('.player') || e.target.closest('#ball')) return;
  
  // Si estamos en modo selección masiva, no hacemos dibujos.
  if (tool === 'arrows' && e.shiftKey) return; 
  
  // Si no está autorizado, no puede dibujar ni tomar notas.
  if (window.db && !window.isAuthorized) return;

  try{board.setPointerCapture(e.pointerId);}catch{}
  let p=clientToBoard(e);
  // Eliminado: if (document.getElementById('snap').checked){ p.x=snapVal(p.x); p.y=snapVal(p.y); }
  
  // Usar el valor de color/grosor del selector activo (Desktop o Mobile)
  const currentStrokeColor = getActiveToolColor();
  const currentStrokeWidth = getActiveToolWidth();

  if (tool==='arrows'){ 
      drawingArrow=true; 
      startPt={x:p.x,y:p.y}; 
  } else if (tool==='pen') {
    drawingStroke=true;
    currentStroke={ 
        points:[`${p.x},${p.y}`], 
        color:currentStrokeColor, 
        width:currentStrokeWidth, 
        dashed:getActiveDashed() 
    };
    strokes.push(currentStroke); renderDraw();
  } else if (tool==='text') {
      // MODO TEXTO: Abrir un prompt para la nota
      const text = prompt("Ingresa el texto para la nota (máx 30 caracteres):");
      if (text && text.trim()) {
          notes.push({ 
              x: p.x, 
              y: p.y, 
              text: text.trim().substring(0, 30), 
              color: currentStrokeColor 
          });
          renderDraw();
      }
      // Volver inmediatamente a la herramienta de flechas/selección
      setTool('arrows');
  }
},{passive:false});

board.addEventListener('pointermove',e=>{
  if (tool === 'text') return; // Ignorar movimiento en modo texto
  if (tool==='arrows' && e.shiftKey) return; // Si estamos en modo selección, ignoramos movimiento de dibujo
  if (tool!=='pen' || !drawingStroke || !currentStroke) return;
  
  // Si no está autorizado, no puede dibujar.
  if (window.db && !window.isAuthorized) return;
  
  let p=clientToBoard(e);
  // Eliminado: if (document.getElementById('snap').checked){ p.x=snapVal(p.x); p.y=snapVal(p.y); }
  const last=currentStroke.points[currentStroke.points.length-1];
  const [lx,ly]=last.split(',').map(Number);
  if (Math.abs(p.x-lx)+Math.abs(p.y-ly) > 0.5){
    currentStroke.points.push(`${p.x},${p.y}`); renderDraw();
  }
},{passive:false});

board.addEventListener('pointerup',e=>{
  if (tool === 'text') return; // Ignorar up en modo texto
  if (tool==='arrows' && e.shiftKey) return; // Si estamos en modo selección, ignoramos up de dibujo
  try{board.releasePointerCapture(pid);}catch{}
  
  // Si no está autorizado, no puede dibujar.
  if (window.db && !window.isAuthorized) return;
  
  let p=clientToBoard(e);
  // Eliminado: if (document.getElementById('snap').checked){ p.x=snapVal(p.x); p.y=snapVal(p.y); }
  
  // Usar el valor de color/grosor del selector activo (Desktop o Mobile)
  const currentStrokeColor = getActiveToolColor();
  const currentStrokeWidth = getActiveToolWidth();

  if (tool==='arrows' && drawingArrow && startPt){
    arrows.push({ 
        x1:startPt.x, 
        y1:startPt.y, 
        x2:p.x, 
        y2:p.y, 
        color:currentStrokeColor, 
        width:currentStrokeWidth, 
        dashed:getActiveDashed() 
    });
    drawingArrow=false; startPt=null; renderDraw();
  }else if (tool==='pen' && drawingStroke && currentStroke){
    drawingStroke=false; renderDraw();
  }
},{passive:false});

// Mapeo de eventos de deshacer/limpiar
btnUndo.addEventListener('click',()=>{
  if (window.db && !window.isAuthorized) { showStatus('No autorizado para deshacer.', 'var(--red)'); return; }
  if (tool==='arrows'){ arrows.pop(); }
  else if (tool==='pen') { strokes.pop(); }
  else if (tool==='text') { notes.pop(); } // NUEVO: DESHACER TEXTO
  renderDraw();
});
btnClear.addEventListener('click',()=>{ 
  if (window.db && !window.isAuthorized) { showStatus('No autorizado para borrar dibujos.', 'var(--red)'); return; }
  arrows=[]; strokes=[]; notes=[]; renderDraw(); // NUEVO: LIMPIAR NOTAS
});

/* ---------- Timeline (Copia de la original) ---------- */
const TLKEY='rb-timeline'; // Ya no se usa local storage
let playing=false, paused=false, playIdx=0, rafId=null, segStart=0, segDur=800;
let fromF=null, toF=null;

function snapshotPlayers(){ return [...playersLayer.children].map(el=>({team:el.dataset.team, number:+el.dataset.number, x:parseFloat(el.style.left), y:parseFloat(el.style.top)})); }
function snapshotBall(){ return {...currentBallPos}; }
function snapshotFrame(){ return { players: snapshotPlayers(), ball: snapshotBall() }; }

function recordFrame(){ 
    if (window.db && !window.isAuthorized) {
        showStatus('No autorizado para grabar pasos de animación.', 'var(--red)');
        return;
    }
    timeline.push(snapshotFrame()); 
    updateScrub(); 
}
// Mapeo de eventos de grabación
btnRecord.addEventListener('click',recordFrame);


function updateScrub(){
  // Actualizar los scrubbers de desktop y mobile
  [scrubber].forEach(s => {
    if (!s) return; // FIX: Null check
    s.max = Math.max(0, timeline.length - 1);
    const v = parseInt(s.value, 10) || 0;
    if (v > s.max) s.value = s.max;
  });
  
  // Actualizar las etiquetas de estado
  const currentFrame = parseInt(scrubber.value, 10) || 0;
  const maxFrame = scrubber.max;
  const label = `${currentFrame}/${maxFrame}`;
  
  scrubLbl.textContent = label;
}
scrubber.addEventListener('input',()=>{ gotoFrame(parseInt(scrubber.value,10)); });

function gotoFrame(i){
  if (!timeline.length) return;
  i=Math.max(0,Math.min(timeline.length-1,i));
  stopPlayback();
  
  // Sincronizar el valor del scrubber en desktop
  [scrubber].forEach(s => { if(s) s.value = i; }); // FIX: Null check
  scrubLbl.textContent=`${i}/${timeline.length-1}`;
  
  const f=timeline[i];
  f.players.forEach(p=>{
    const el=[...playersLayer.children].find(e=>e.dataset.team===p.team && +e.dataset.number===p.number);
    if (el){ el.style.left=p.x+'px'; el.style.top=p.y+'px'; }
  });
  if (f.ball){ placeBall(f.ball.x, f.ball.y); }
  clearPlayerSelection(); // Limpiar selección al cambiar de frame
}

// CORRECCIÓN 4: Lógica unificada de Play/Pause
function togglePlayPause() {
    if (playing) {
        paused = true;
        playing = false;
        btnPlayPause.textContent = 'Reanudar';
        btnPlayPause.classList.add('primary');
    } else if (paused) {
        paused = false;
        playing = true;
        btnPlayPause.textContent = 'Pausa';
        btnPlayPause.classList.remove('primary');
        if (!rafId) rafId = requestAnimationFrame(animate); // Reanudar animación
    } else {
        // Inicializar la reproducción
        playTimeline();
        btnPlayPause.textContent = 'Pausa';
        btnPlayPause.classList.remove('primary');
    }
}

// Mapeo de eventos de control de reproducción
btnPlayPause.addEventListener('click', togglePlayPause);

function stopPlayback(){ 
    playing=false; 
    paused=false; 
    if (rafId){ cancelAnimationFrame(rafId); rafId=null; } 
    btnPlayPause.textContent = 'Reproducir';
    btnPlayPause.classList.add('primary');
}
btnStop.addEventListener('click', stopPlayback);

function toMap(f){ const m=new Map(); f.players.forEach(p=>m.set(p.team+'#'+p.number,p)); return m; }
function lerp(a,b,t){ return a+(b-a)*t; }

function animate(now){
  if (!playing || paused) { rafId=requestAnimationFrame(animate); return; }
  const u=Math.max(0,Math.min(1,(now-segStart)/segDur));
  const A=toMap(fromF), B=toMap(toF);

  [...playersLayer.children].forEach(el=>{
    const key=el.dataset.team+'#'+el.dataset.number;
    const pa=A.get(key)||{x:parseFloat(el.style.left),y:parseFloat(el.style.top)};
    const pb=B.get(key)||pa;
    el.style.left=lerp(pa.x,pb.x,u)+'px';
    el.style.top =lerp(pa.y,pb.y,u)+'px';
  });
  placeBall(lerp(fromF.ball.x,toF.ball.x,u), lerp(fromF.ball.y,toF.ball.y,u));

  if (u>=1){
    playIdx++;
    
    // Actualizar labels de scrubbers (Desktop)
    scrubber.value = playIdx;
    scrubLbl.textContent=`${playIdx}/${timeline.length-1}`;

    if (playIdx>=timeline.length-1){ 
        stopPlayback(); // Termina la reproducción
        return; 
    }
    fromF=timeline[playIdx]; toF=timeline[playIdx+1]; segStart=performance.now();
  }
  rafId=requestAnimationFrame(animate);
}

function playTimeline(){
  if (timeline.length<2){ showStatus('Necesitás al menos 2 pasos grabados para animar.', 'var(--warn)'); return; }
  
  // Usar la velocidad del control visible (desktop)
  const speedEl = document.getElementById('speed');
  let speedVal = 800; // Default
  if (speedEl) {
      speedVal = parseInt(speedEl.value || 800, 10);
  }
  
  segDur=Math.max(100, speedVal);
  
  if (!paused){
    playIdx=parseInt(scrubber.value,10)||0;
    if (playIdx>=timeline.length-1) playIdx=0;
    fromF=timeline[playIdx]; toF=timeline[playIdx+1];
    gotoFrame(playIdx);
  }
  paused=false; playing=true; segStart=performance.now();
  if (!rafId) rafId=requestAnimationFrame(animate);
}
// El resto del código de Exportación y Auxiliares permanece igual.
</script>
</body>
</html>
